<!doctype html><html lang=en-gb><title>Uniform random selection from a channel | George Thomas</title>
<meta charset=utf-8><meta name=generator content="Hugo 0.139.3"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://geotho.github.io/css/index.css><link rel=stylesheet href=https://geotho.github.io/css/classes.css><link rel=canonical href=https://geotho.github.io/post/2020-06-29-uniform-random-selection-from-channel/><link rel=alternate type=application/rss+xml href title="George Thomas"><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-DXK82H4CPF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DXK82H4CPF")}</script><body><header class=icons><a href=https://geotho.github.io/>George Thomas</a><nav><a href=/about/>About
</a><a href=/projects/>Projects</a></nav></header><meta name=twitter:card content="summary"><meta name=twitter:title content="Uniform random selection from a channel"><meta name=twitter:description content="Selecting a item uniformly at random from an array is quite easy:
func randomPickSlice(items []string) string { i := rand.Intn(len(items)) return items[i] } How could we do this with a channel, rather than a slice?
One way would be simply to read items to a slice first, then use randomPickSlice:
func randomPickChan(items <-chan string) string { var allItems []string for s := range items { allItems = append(allItems, s) } return randomPickSlice(allItems) } But this requires us to store all the items in memory at the same time, which might not be possible. Can we do better?"><meta property="og:url" content="https://geotho.github.io/post/2020-06-29-uniform-random-selection-from-channel/"><meta property="og:site_name" content="George Thomas"><meta property="og:title" content="Uniform random selection from a channel"><meta property="og:description" content="Selecting a item uniformly at random from an array is quite easy:
func randomPickSlice(items []string) string { i := rand.Intn(len(items)) return items[i] } How could we do this with a channel, rather than a slice?
One way would be simply to read items to a slice first, then use randomPickSlice:
func randomPickChan(items <-chan string) string { var allItems []string for s := range items { allItems = append(allItems, s) } return randomPickSlice(allItems) } But this requires us to store all the items in memory at the same time, which might not be possible. Can we do better?"><meta property="og:locale" content="en_gb"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-06-29T16:26:00+01:00"><meta property="article:modified_time" content="2020-06-29T16:26:00+01:00"><article><header><h1>Uniform random selection from a channel</h1><time datetime=2020-06-29T16:26:00+01:00>June 29, 2020</time></header><p>Selecting a item uniformly at random from an array is quite easy:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>randomPickSlice</span>(<span style=color:#a6e22e>items</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(len(<span style=color:#a6e22e>items</span>))
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>items</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>How could we do this with a channel, rather than a slice?</p><p>One way would be simply to read items to a slice first, then use <code>randomPickSlice</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>randomPickChan</span>(<span style=color:#a6e22e>items</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>allItems</span> []<span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>items</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>allItems</span> = append(<span style=color:#a6e22e>allItems</span>, <span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>randomPickSlice</span>(<span style=color:#a6e22e>allItems</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But this requires us to store all the items in memory at the same time, which might not be possible. Can we do better?</p><h2 id=using-o1-space>Using O(1) space</h2><p>Rather than storing all the elements we&rsquo;ve ever seen, let&rsquo;s just persist a &ldquo;chosen-one&rdquo; candidate. We&rsquo;ll initialise the candidate to be the first item from the channel. Then, whenever we see a new item from the channel, we could choose whether to stick with the old candidate or replace the candidate with the new value. Once we exhaust the channel, we return the candidate.</p><p>How do we decide whether to stick or swap?</p><p>We could do a 50/50 coin-flip each time. But this doesn&rsquo;t select uniformly at random: the chance of returning the first item after seeing n items is \({\frac{1}{2^{n-1}}}\).</p><p>Instead, we can maintain a counter <code>k</code> of the items we&rsquo;ve seen so far. And for every new item, we can either pick it with probability <code>1/k</code> or stick with the old thing with probability <code>1-1/k</code> or <code>(k-1)/k</code>.</p><p>How can we prove that any candidate value is selected uniformly at random i.e. with probability <code>1/n</code>?</p><h3 id=an-inductive-proof>An inductive proof</h3><p>We have to prove:</p><ol><li>That the base-case holds.</li><li>That the k+1th case holds if the kth case holds.</li></ol><p>Our base-case is that of the 1-element channel. Because we initialise the candidate to be the first element, and because there are no other elements to swap it out for, we return the first element with probability 1. ✅</p><p>Let&rsquo;s assume that the kth-case holds. So we have seen <code>k</code> items and our candidate has been selected with probability <code>1/k</code>.</p><p>When we see the k+1th item, we either swap out our candidate with probability <code>1/k+1</code>, or stick with our current candidate with probability <code>1-(1/k+1)</code>.</p><p>If we swap it out, then the new candidate will have been selected with probability <code>1/k+1</code>.</p><p>If we stick with the current candidate, it has now been selected with a probability:</p><p>$$
\frac{1}{k}(1-\frac{1}{k+1}) =
\frac{1}{k}(\frac{k}{k+1}) =
\frac{1}{k+1}
$$</p><p>So whether we stick or swap, we&rsquo;re left with a candidate that has been selected with probability <code>1/k+1</code>. ✅</p><h3 id=what-does-the-code-look-like>What does the code look like?</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>randomPickChan</span>(<span style=color:#a6e22e>items</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>candidate</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>items</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>items</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>k</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#a6e22e>k</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// or equivalently r == k-1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>candidate</span> = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>candidate</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=can-we-do-better>Can we do better?</h3><p>I&rsquo;d be surprised and very interested to hear. I guess if you knew how many values there would be in total, you could just pick a <code>p</code> such that <code>0 &lt;= p &lt; n</code>, throw away the first <code>p</code> values and return the p-th one immediately.</p></article></body></html>