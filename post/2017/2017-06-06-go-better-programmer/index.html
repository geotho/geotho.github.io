<!doctype html><html lang=en-gb><title>Ways Go made me a better programmer | George Thomas</title><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://geotho.github.io/css/index.css><link rel=stylesheet href=https://geotho.github.io/css/classes.css><link rel=canonical href=https://geotho.github.io/post/2017/2017-06-06-go-better-programmer/><link rel=alternate type=application/rss+xml href title="George Thomas"><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-DXK82H4CPF","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><body><header class=icons><a href=https://geotho.github.io/>George Thomas</a><nav><a href=/about/>About</a>
<a href=/projects/>Projects</a></nav></header><article><header><h1>Ways Go made me a better programmer</h1><time datetime=2017-06-06T00:00:00Z>June 06, 2017</time></header><p>Language influences thought, and programming languages are no different. Writing code in a new language makes you frame the problem in fresh way. Go has narrowed my focus in a few areas, and I feel like a better programmer as a result. Some of the features of Go that have helped me improve are below.</p><h3 id=interfaces>Interfaces</h3><p>Interfaces in Go are easy to create and to implement. You can make any type implement any interface by creating a custom type and attaching methods to it. You don’t explicitly declare that the type implements the interface, as you do in e.g. Java, but you can still assert this at compile time.</p><p>The Go mantra &ldquo;functions should expect interfaces and return structs&rdquo; drums home this idea that you don’t actually care about the thing you are getting, you only care about what it can do. This requires you to focus on the narrowest set of required functionality. The standard library’s <code>sort</code> package provides a beautiful illustration.</p><h3 id=style-guide>Style guide</h3><p>The standard library code formatter, <code>gofmt</code>, is a revelation. Thank goodness I no longer need to spend time formatting code, or deciding whether to use tabs or spaces, or anything else that doesn’t matter as long as it’s consistent.</p><p>But it goes further than that: <a href=https://golang.org/doc/effective_go.html>Effective Go</a> provides details on how to write Go that cannot be captured by an automatic formatter. Tips like <a href=https://github.com/golang/go/wiki/CodeReviewComments#indent-error-flow>&ldquo;keep the main logic unindented&rdquo;</a> help ensure code written by different people is consistent and readable.</p><p>Go optimises for consistency and readability. You and your team will be able to understand each other’s code faster and the developing-reviewing-maintaining lifecycle benefits.</p><h3 id=opinionated--theres-only-one-way-to-code>Opinionated – there’s only one way to code</h3><p>Go’s language design is deliberately simple. It lacks generics. It lacks while loops. It lacks classes. If you are a Lisp programmer, or have read <a href=http://www.paulgraham.com/avg.html>Paul Graham’s blog post</a> on it, you might be tempted to ask &ldquo;How can you get anything done in Go? It doesn&rsquo;t even have {generics, while loops, classes, metaprogramming&mldr;}.&rdquo;</p><p>I’ve used languages which are more powerful (i.e. more abstract) than Go. But I feel more productive in Go than in these other languages. Why? I find the simplicity (i.e. lack of power) refreshing. Power comes with choice. And choice leads to decision making. And decision making leads to procrastination and disagreement.</p><p>How many times have I started writing a for loop in Python, until I remember than I can also write a list comprehension to accomplish the same thing? Or the map function with a lambda? Any time I have to ask myself &ldquo;should I use language feature X or Y to accomplish this same goal?&rdquo; is a source of programming impedance, and a chance to ruin flow.</p><p>I remember another time where one engineer used a Java 8 lambda when a more senior engineer replaced it with a for loop. How much time could have been saved here if only the for loop existed in the first place? How much time and decision fatigue might be saved in aggregate?</p><p>Go avoids these problems by only have one way to accomplish something. Want to create a new list where each element is the square of some other list? Write a loop. Want to filter some of these elements? Write a loop.</p><p>I found that by narrowing the amount of ways I could accomplish the same goal, and thus removing minor decisions I had to make during day-to-day coding, I found a sense of flow much easier.</p><h3 id=concurrency>Concurrency</h3><p>Go’s concurrency primitives are built into the language and are first class citizens of it. I’ve never had concurrent programming make so much sense to me as when I use Go’s <code>sync</code> package. I found it far easier to inject performance-enhancing concurrency into my programs in Go than in e.g. Java.</p><h3 id=table-driven-testing>Table-driven testing</h3><p>Table-drive tests contain a list of (input, expected output) pairs. This enables unit tests which:</p><ul><li>Force modular, unit-testable code.</li><li>Focus on the test data, not the extraneous mocking etc. that is usually required for testing.</li><li>Clearly define and document the function under test.</li></ul><p>It is Go’s structs that make table-driven tests easier to write. Table driven tests in Java would require another testcase class, which always seems more tedious to write and to use.</p></article></body></html>