<!doctype html><html lang=en-gb><title>Whiteboarding coding in the wild: reversing domains for BigTable | George Thomas</title>
<meta charset=utf-8><meta name=generator content="Hugo 0.138.0"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://geotho.github.io/css/index.css><link rel=stylesheet href=https://geotho.github.io/css/classes.css><link rel=canonical href=https://geotho.github.io/post/2017/2017-02-12-reversing-domains/><link rel=alternate type=application/rss+xml href title="George Thomas"><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-DXK82H4CPF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DXK82H4CPF")}</script><body><header class=icons><a href=https://geotho.github.io/>George Thomas</a><nav><a href=/about/>About
</a><a href=/projects/>Projects</a></nav></header><meta name=twitter:card content="summary"><meta name=twitter:title content="Whiteboarding coding in the wild: reversing domains for BigTable"><meta name=twitter:description content="A common complaint about whiteboard coding questions is that they do not resemble a software engineer’s day-to-day work. So I like to note the times when these fun toy algorithms have actually come in handy.
A classic whiteboard coding question is as follows:
“Given a string containing a sentence, reverse the order of the words in that sentence.”
So “the quick brown fox” should become “fox brown quick the”.
This is the same problem as reversing domain components for Google BigTable keys. Given some row keys that should contain domains like “foo.example.co.uk” and “bar.example.co.uk”, it is wise to store them in component reverse order e.g. as “uk.co.example.foo” and “uk.co.example.bar”."><meta property="og:url" content="https://geotho.github.io/post/2017/2017-02-12-reversing-domains/"><meta property="og:site_name" content="George Thomas"><meta property="og:title" content="Whiteboarding coding in the wild: reversing domains for BigTable"><meta property="og:description" content="A common complaint about whiteboard coding questions is that they do not resemble a software engineer’s day-to-day work. So I like to note the times when these fun toy algorithms have actually come in handy.
A classic whiteboard coding question is as follows:
“Given a string containing a sentence, reverse the order of the words in that sentence.”
So “the quick brown fox” should become “fox brown quick the”.
This is the same problem as reversing domain components for Google BigTable keys. Given some row keys that should contain domains like “foo.example.co.uk” and “bar.example.co.uk”, it is wise to store them in component reverse order e.g. as “uk.co.example.foo” and “uk.co.example.bar”."><meta property="og:locale" content="en_gb"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-02-12T00:00:00+00:00"><meta property="article:modified_time" content="2017-02-12T00:00:00+00:00"><article><header><h1>Whiteboarding coding in the wild: reversing domains for BigTable</h1><time datetime=2017-02-12T00:00:00Z>February 12, 2017</time></header><p>A common complaint about whiteboard coding questions is that they do not resemble a software engineer’s day-to-day work.
So I like to note the times when these fun toy algorithms have actually come in handy.</p><p>A classic whiteboard coding question is as follows:</p><blockquote><p>&ldquo;Given a string containing a sentence, reverse the order of the words in that sentence.&rdquo;</p></blockquote><p>So &ldquo;the quick brown fox&rdquo; should become &ldquo;fox brown quick the&rdquo;.</p><p>This is the same problem as reversing domain components for Google BigTable keys. Given some row keys that should contain domains like &ldquo;foo.example.co.uk&rdquo; and &ldquo;bar.example.co.uk&rdquo;, it is wise to store them in component reverse order e.g. as &ldquo;uk.co.example.foo&rdquo; and &ldquo;uk.co.example.bar&rdquo;.</p><p>That way, you can make use of BigTable’s prefix scanning to find all entries related to &ldquo;*.example.co.uk&rdquo;. (Our actual use case was to reverse emails so that &ldquo;<a href=mailto:hello.world@example.co.uk>hello.world@example.co.uk</a>&rdquo; became &ldquo;<a href=mailto:uk.co.example@hello.world>uk.co.example@hello.world</a>&rdquo;, for the same reason).</p><h3 id=an-initial-approach>An initial approach</h3><p>One method might be to split the string on dots, reverse that resulting array and then join it back on dots:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ReverseDomain</span>(<span style=color:#a6e22e>domain</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>parts</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Split</span>(<span style=color:#a6e22e>domain</span>, <span style=color:#e6db74>&#34;.&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rev</span>(<span style=color:#a6e22e>parts</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>parts</span>, <span style=color:#e6db74>&#34;.&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>rev</span>(<span style=color:#a6e22e>ss</span> []<span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>ss</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ss</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>ss</span>[len(<span style=color:#a6e22e>ss</span>)<span style=color:#f92672>-</span><span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] = <span style=color:#a6e22e>ss</span>[len(<span style=color:#a6e22e>ss</span>)<span style=color:#f92672>-</span><span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], <span style=color:#a6e22e>ss</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>How fast does this go? We could write a benchmark to find out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkReverseDomain</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>ReportAllocs</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ReverseDomain</span>(<span style=color:#e6db74>&#34;foo.bar.baz.co.uk&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;d get something like the following result:</p><pre tabindex=0><code>BenchmarkReverseDomain-8       	 5000000       	       394 ns/op       	     144 B/op  	       3 allocs/op
</code></pre><p>which means it takes ~400 nanoseconds to reverse <code>foo.bar.baz.co.uk</code> on my machine, and does three allocations in the process.</p><h3 id=can-it-go-any-faster>Can it go any faster?</h3><p>We can use a common trick to avoid allocating slices of strings (aka slices of slices of bytes): reverse the entire string, then unreverse each component separately.</p><p>So you do the following steps:</p><pre tabindex=0><code>foo.bar.baz.co.uk
ku.oc.zab.rab.oof (by reversing the whole string)
uk.oc.zab.rab.oof (reverse the ku)
uk.co.zab.rab.oof (reverse the oc)
uk.co.baz.rab.oof ( etc. )
uk.co.baz.bar.oof
uk.co.baz.bar.foo
</code></pre><p>Because this reversing happens in place, you don&rsquo;t need to allocate any extra memory for doing it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ReverseDomainFaster</span>(<span style=color:#a6e22e>domain</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dom</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#a6e22e>domain</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>revB</span>(<span style=color:#a6e22e>dom</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lastDotIdx</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>dom</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;.&#39;</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>revB</span>(<span style=color:#a6e22e>dom</span>[<span style=color:#a6e22e>lastDotIdx</span>:<span style=color:#a6e22e>i</span>])
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>lastDotIdx</span> = <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>revB</span>(<span style=color:#a6e22e>dom</span>[<span style=color:#a6e22e>lastDotIdx</span>:])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> string(<span style=color:#a6e22e>dom</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>revB</span>(<span style=color:#a6e22e>b</span> []<span style=color:#66d9ef>byte</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>b</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>b</span>[len(<span style=color:#a6e22e>b</span>)<span style=color:#f92672>-</span><span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] = <span style=color:#a6e22e>b</span>[len(<span style=color:#a6e22e>b</span>)<span style=color:#f92672>-</span><span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], <span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And if you benchmark that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkReverseDomainFaster</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>ReportAllocs</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ReverseDomainFaster</span>(<span style=color:#e6db74>&#34;foo.bar.baz.co.uk&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You might get this:</p><pre tabindex=0><code>BenchmarkReverseDomainFaster-8         	10000000       	       139 ns/op       	      32 B/op  	       1 allocs/op
</code></pre><p>Hurray! It&rsquo;s about three times faster.</p><p>Where does that one allocation come from? Because we&rsquo;re returning a copy of the string rather than the original. Eagle-eyed readers might suspect there should be two allocations: <code>dom := []byte(domain)</code> and <code>return string(dom)</code>, but it seems like Go&rsquo;s compiler optimises one of these away (after all, a string is just a byte slice).</p><p>We can get some evidence for this theory by running our tests with escape analysis: <code>go test -v ./... -bench . -gcflags '-m'</code> and seeing the following lines:</p><pre tabindex=0><code>./domainreverse.go:27: string(dom) escapes to heap
./domainreverse.go:13: ReverseDomainFaster domain does not escape
./domainreverse.go:14: ReverseDomainFaster ([]byte)(domain) does not escape
</code></pre><p>You might also want to write some table-driven tests so make sure your algorithm is working as intended:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestReverseDomain</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tests</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>want</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	}{
</span></span><span style=display:flex><span>		{<span style=color:#e6db74>&#34;test&#34;</span>, <span style=color:#e6db74>&#34;test&#34;</span>},
</span></span><span style=display:flex><span>		{<span style=color:#e6db74>&#34;foo.bar.baz.co.uk&#34;</span>, <span style=color:#e6db74>&#34;uk.co.baz.bar.foo&#34;</span>},
</span></span><span style=display:flex><span>		{<span style=color:#e6db74>&#34;foo.bar.baz.co.uk.&#34;</span>, <span style=color:#e6db74>&#34;.uk.co.baz.bar.foo&#34;</span>},
</span></span><span style=display:flex><span>		{<span style=color:#e6db74>&#34;.....&#34;</span>, <span style=color:#e6db74>&#34;.....&#34;</span>},
</span></span><span style=display:flex><span>		{<span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>tt</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>tests</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>got</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ReverseDomain</span>(<span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>input</span>); <span style=color:#a6e22e>got</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>want</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;ReverseDomain actual=%s, expected=%s&#34;</span>, <span style=color:#a6e22e>got</span>, <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>want</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>got</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ReverseDomainFaster</span>(<span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>input</span>); <span style=color:#a6e22e>got</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>want</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;ReverseDomainFaster actual=%s, expected=%s&#34;</span>, <span style=color:#a6e22e>got</span>, <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>want</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=can-it-go-even-faster>Can it go even faster?</h3><p>If we could avoid the allocation by mutating the original domain instead, our code should go much faster:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ReverseDomainInPlace</span>(<span style=color:#a6e22e>dom</span> []<span style=color:#66d9ef>byte</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>revB</span>(<span style=color:#a6e22e>dom</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lastDotIdx</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>dom</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;.&#39;</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>revB</span>(<span style=color:#a6e22e>dom</span>[<span style=color:#a6e22e>lastDotIdx</span>:<span style=color:#a6e22e>i</span>])
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>lastDotIdx</span> = <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>revB</span>(<span style=color:#a6e22e>dom</span>[<span style=color:#a6e22e>lastDotIdx</span>:])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note that to make it clear that the function mutates its arguments, I choose not to return anything.</p><p>If you write one final benchmark for this in-place version:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkReverseDomainFasterInPlace</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>ReportAllocs</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ReverseDomainInPlace</span>([]byte(<span style=color:#e6db74>&#34;foo.bar.baz.co.uk&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can see that it is a lot faster than our original function and does no allocations:</p><pre tabindex=0><code>BenchmarkReverseDomain-8                3000000   404 ns/op    144 B/op    3 allocs/op
BenchmarkReverseDomainFaster-8         10000000   133 ns/op     32 B/op    1 allocs/op
BenchmarkReverseDomainFasterInplace-8  20000000    73.4 ns/op    0 B/op    0 allocs/op
</code></pre><p>What will you do with your extra 330ns and 144 bytes of memory?</p></article></body></html>